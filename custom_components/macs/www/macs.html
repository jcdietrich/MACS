<!doctype html>
<html>
<head>
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta charset="utf-8">
	<style>
		


		/* #################################### VARIABLES ############################################ */
		:root{
			/* Character Colours */
			--sclera-gradient-shadow: #001d14;
			--sclera-gradient-fill: #00c7bd;
			--sclera-gradient-highlight: #ffffff;
			--sclera-outer-glow: #46f6d8;
			--sclera-inner-glow: #038c7c;

			--iris-fill: #000000;	
			--iris-outer-glow: #46f6d8;
			--iris-inner-glow: #038c7c;

			--pupil-fill: #ffffff;	
			--pupil-inner-glow: #8cf5ff;	
			--pupil-outer-glow: #8cf5ff; 

			--mouth-fill: #6dd3d7;
			--mouth-glow: #30cfc6;

			--brow-fill: #6dd3d7;
			--brow-glow: #00ffdd;

			/* ~60% screen width */
			--faceScale: 0.60; 

			/* Screen Dimming */
			--brightness-level: 1;

			/* weather intensity */
			--weather-intensity: 0.8; 
			
		}
	
		/* #################################### PAGE / LAYOUT ############################################ */
		html,body{
			height:100%;
			margin:0;
			background:#000;
			overflow:hidden;
			font-family:'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
		}
		body{
			touch-action:manipulation;
		}

		/* Stage gives you padding + room for movement/overlays */
		.stage{
			position:fixed; 
			inset:0;
			display:flex; 
			align-items:center; 
			justify-content:center;
			padding: 7vmin;
			opacity: var(--brightness-level);
		}



		/* #################################### CHARACTER ############################################ */

		/* Character wrapper size ~60% of viewport width, clamped for small/large screens */
		.char{
			position:relative;
			width: min(60vw, 620px);
			max-width: 60vw;
			aspect-ratio: 1 / 1;
			transform: translateZ(0);
			animation: idleFloat 9s ease-in-out infinite;
		}

		/* Eyebrows */
		.brow{
			fill: var(--brow-fill);
			stroke: var(--brow-fill);
			stroke-width: 10;
			stroke-linecap:round; 
			filter: drop-shadow(0 0 8px var(--brow-glow));
			transform-origin:center; 
		}

		/* Sclera */
		.scleraOuterGlow{ 
			fill:var(--sclera-gradient-fill);
			opacity:1;
			filter:url(#eyeOuterGlow); 
		}
		/* Iris */
		.IrisOuterGlow{ 
			fill:var(--iris-fill);
			opacity:1;
			filter:url(#irisOuterGlow); 
		}
		/* Pupils */
		.pupil{ 
			fill: var(--pupil-fill);
			filter: drop-shadow(0 0 8px var(--pupil-outer-glow)); 
			transform-origin:center; 
		}

		/* Mouth */
		.mouth{
			fill: var(--mouth-fill);
			stroke: var(--mouth-fill);
			stroke-width: 10px;
			stroke-linecap:round; 
			filter: drop-shadow(0 0 10px var(--mouth-glow)); 
		}



		

		/* #################################### GLOBAL ANIMATION ############################################ */

		/* Adds idle float to whole character */
		@keyframes idleFloat{
			0%,100%{ transform: translate(0,0); }
			50%{ transform: translate(0, 1.2vmin); }
		}

		/* Blink */
		.blink{
			transform-origin:center;
			animation: blink 6.2s infinite;
		}
		@keyframes blink{
			0%,92%,100%{ transform: scaleY(1); }
			94%{ transform: scaleY(0.08); }
			96%{ transform: scaleY(1); }
		}
		
		/* Hide all mouth shapes by default */
		#mouth-idle, #mouth-bored, #mouth-listening, #mouth-thinking, #mouth-surprised, #mouth-confused, #mouth-sleeping, #mouth-happy{display:none}





		/* #################################### MOODS ############################################ */

		/* CONFUSED */
		.mood-confused .browL{ transform: translate(10px, -40px) rotate(-10deg)}
		.mood-confused .browR{ transform: translate(-5px,40px) rotate(5deg)}
		.mood-confused #mouth-confused{ display:block; fill:none}
		.mood-confused #face{ transform: rotate(10deg)}
		.mood-confused .blink{animation: confused-blink 2s infinite}
		@keyframes confused-blink{
			6%, 18%{ transform: scaleY(0.08); }
			0%, 12%, 24%{ transform: scaleY(1); }
		}


		/* BORED */
		.mood-bored #eyeBezelL{transform: translate(200px, 260px) rotate(-30deg) translate(-200px, -260px)}
		.mood-bored #eyeBezelR{transform: translate(400px, 260px) rotate(30deg) translate(-400px, -260px)}
		.mood-bored #brows{display: block;}
		.mood-bored .browL{ transform: translateX(50px) translateY(-70px) rotate(-40deg); }
		.mood-bored .browR{ transform: translateX(-50px) translateY(-70px) rotate(40deg); }
		.mood-bored #mouth-bored{display:block;fill:none;}
		.mood-bored .iris{ transform: translate(5px, 30px)}

		/* HAPPY */
		.mood-happy #mouth-happy{ display:block; stroke:none}

		/* IDLE */
		.mood-idle #mouth-idle{ display:block; fill:none}
		.mood-idle .iris{ animation: iris-idle 10s ease-in-out infinite}
		@keyframes iris-idle{
			0%, 100%{ transform: translate(20px,0px); }
			50%{ transform: translate(-20px,0px); }
		}

		/* LISTENING */
		.mood-listening .brow{ animation: brow-listening 1.2s ease-in-out infinite; }
		.mood-listening #mouth-listening{ display:block; fill:none}
		.mood-listening #face{ transform: rotate(10deg)}
		.mood-listening .iris{ animation: iris-listening 1.4s ease-in-out infinite; }
		@keyframes brow-listening{
			0%,100%{ transform: translateY(0); }
			50%{ transform: translateY(-6px); }
		}
		@keyframes iris-listening{
			 0%,100%{ transform: translate(-10px,-10px)}
			 50%{ transform: translate(10px,10px) } 
		}

		/* SLEEPING */
		.mood-sleeping .blink{animation: none}
		.mood-sleeping .iris, .mood-sleeping .pupil, .mood-sleeping .brow{opacity:0.0}
		.mood-sleeping .eyeball{opacity: 0.3}
		.mood-sleeping #leftEye .eyeball{transform: translateX(-20px) translateY(-0px) rotate(-3deg) scaleX(0.8) scaleY(0.01)}
		.mood-sleeping #rightEye .eyeball{transform: translateX(20px) translateY(-0px) rotate(3deg) scaleX(0.8) scaleY(0.01)}
		.mood-sleeping #mouth-sleeping{opacity:0.2; display:block;}

		/* SURPRISED */
		.mood-surprised .brow{ animation: brow-surprised 1.8s ease-in-out infinite; }
		.mood-surprised #mouth-surprised{ display:block; }
		.mood-surprised .iris{transform-origin:center;}
		.mood-surprised #leftEye .iris{ transform: translate(30px, 10px) scale(1.3)}
		.mood-surprised #rightEye .iris{ transform: translate(-30px, 10px) scale(1.3)}
		@keyframes brow-surprised{
			0%,100%{ transform: translateY(-2px); }
			10%{ transform: translateY(-10px);  }
			25%{ transform: translateY(-6px); }
		}

		/* THINKING */
		.mood-thinking .browL{ transform: translateY(40px)  }
		.mood-thinking .browR{ transform: translateY(30px)  }
		.mood-thinking #face{ transform: rotate(5deg)}
		.mood-thinking #mouth-thinking{ display:block; fill:none}
		.mood-thinking .iris{animation: iris-thinking 2.6s linear infinite;}
		@keyframes iris-thinking{
			0%, 100%{ transform: translate(-10px,15px); }
			50%{ transform: translate(10px,15px); }
		}	




		/* #################################### WEATHER ############################################ */

		/* Weather overlays */
		.fx{ position:absolute; inset:-10vmin; pointer-events:none; opacity:0; }
		body.wx-rain .fx-rain{ opacity: calc(0.9 * var(--weather-intensity)); }
		body.wx-wind .fx-wind{ opacity: calc(0.9 * var(--weather-intensity)); }
		body.wx-hot  .fx-hot{  opacity: calc(0.9 * var(--weather-intensity)); }
		body.wx-cold .fx-cold{ opacity: calc(0.9 * var(--weather-intensity)); }

		/* Rain */
		.drop{ fill: rgba(190,240,255,0.35); filter: blur(0.2px); animation: rainFall 1.2s linear infinite; }
		.drop.d2{ animation-duration: 1.6s; opacity:0.25; }
		.drop.d3{ animation-duration: 1.9s; opacity:0.22; }
		@keyframes rainFall{
			from{ transform: translateY(-40%); }
			to{ transform: translateY(140%); }
		}

		/* Wind: gentle sway + streaks */
		body.wx-wind .char{ animation: windSway 2.8s ease-in-out infinite; }
		@keyframes windSway{
			0%,100%{ transform: translate(-0.6vmin, 0.4vmin) rotate(-0.8deg); }
			50%{ transform: translate(0.8vmin, -0.4vmin) rotate(1deg); }
		}
		.streak{ stroke: rgba(190,240,255,0.18); stroke-width:6; stroke-linecap:round; animation: streakMove 1.6s linear infinite; }
		.streak.s2{ animation-duration: 2.2s; opacity:0.12; }
		@keyframes streakMove{
			from{ transform: translateX(-20%); }
			to{ transform: translateX(140%); }
		}

		/* Hot: sweat + shimmer (no warm colours) */
		.sweat{ fill: rgba(190,240,255,0.28); animation: sweatDrip 2.6s ease-in-out infinite; }
		@keyframes sweatDrip{
			0%,60%{ transform: translateY(-6px); opacity:0; }
			70%{ opacity:0.6; }
			100%{ transform: translateY(40px); opacity:0; }
		}
		.shimmer{ opacity:0.14; filter: blur(1px); animation: shimmer 1.1s ease-in-out infinite alternate; }
		@keyframes shimmer{ from{ transform: translateY(0); } to{ transform: translateY(-6px); } }

		/* Cold: shiver + breath */
		body.wx-cold .char{ animation: coldShiver 0.22s infinite alternate; }
		@keyframes coldShiver{
			from{ transform: translate(-1px,1px); }
			to{ transform: translate(1px,-1px); }
		}
		.breath{ fill: rgba(200,245,255,0.26); filter: blur(6px); animation: breath 3.2s infinite; }
		@keyframes breath{
			0%{ opacity:0; transform: translate(0,10px) scale(0.7); }
			18%{ opacity:0.55; }
			100%{ opacity:0; transform: translate(0,-46px) scale(1.6); }
		}

		/* Chat viewport */
#messages{
  position: absolute;
  left: 0; right: 0; bottom: 0;
  padding: 14px;
  box-sizing: border-box;

  height: 180px;                 /* KEY: must be a real height */
  overflow: hidden;              /* KEY: clip overflow */
  display: flex;
  flex-direction: column;
  justify-content: flex-end;     /* now it can actually work */

  margin-left: auto;
  margin-right: auto;
  max-width: 600px;

}

		/* Inner top shadow / fade */
		#messages::before{
  content:"";
  position: absolute;
  left: 0; right: 0; top: 0;
  height: 40px;
  pointer-events: none;
  background: linear-gradient(to bottom, rgba(0,0,0,1), rgba(0,0,0,0.2));
		}

		/* Chat stack */
		.assist-chat{
  display: flex;
  flex-direction: column;
		}

		/* A single interaction group (user + system) */
		.assist-turn{
			display: flex;
			flex-direction: column;
		}

		/* Bubble base */
		.bubble{
			max-width: 78%;
			font-size: 14px;
			word-wrap: break-word;
			overflow-wrap: anywhere;
			padding: 5px 0px;
		}

		/* Right aligned user bubble */
		.bubble.user{
			align-self: flex-end;
			color: #fff;
		}

		/* Left aligned system bubble */
		.bubble.system{
			align-self: flex-start;
			color: var(--pupil-inner-glow);
		}

		/* Optional tiny timestamp */
		.bubble-meta{
			font-size: 11px;
			margin-top: 4px;
		}
		.bubble.user .bubble-meta{
			text-align: right;
			color:#999;
		}
		.bubble.system .bubble-meta{
			color:var(--sclera-inner-glow);
		}
	</style>
</head>

<body class="mood-idle wx-none">
	<div class="stage">
		<div class="char" id="char">
			<!-- Face -->
			<svg viewBox="0 0 600 600" width="100%" height="100%" id="face">
				<defs>
					<!-- EYE  BEZEL -->
						<!-- Layer 1: dark bezel gradient -->
						<linearGradient id="bezelDark" x1="0%" y1="0%" x2="0%" y2="100%">
							<stop offset="40%" stop-color="#323941"/>
							<stop offset="60%" stop-color="#111213"/>
							<stop offset="80%" stop-color="#323941"/>
						</linearGradient>

						<!-- Layer 2: metallic highlight gradient -->
						<linearGradient id="bezelMetal" x1="0%" y1="0%" x2="0%" y2="100%">
							<stop offset="30%" stop-color="#78838e"/>
							<stop offset="50%" stop-color="#d6dbe0"/>
							<stop offset="60%" stop-color="#d6dbe0"/>
							<stop offset="80%" stop-color="#78838e"/>
						</linearGradient>

					<!-- SCLERA -->
						<!-- Sclera gradient fill -->
						<radialGradient id="scleraFill" cx="50%" cy="90%" r="78%">
							<stop offset="0%"  stop-color="var(--sclera-gradient-highlight)"/>
							<stop offset="30%" stop-color="var(--sclera-gradient-fill)"/>
							<stop offset="50%" stop-color="var(--sclera-gradient-fill)"/>
							<stop offset="100%" stop-color="var(--sclera-gradient-shadow)"/>
						</radialGradient>

						<!-- ScleraInner glow -->
						<radialGradient id="scleraInnerGlow" cx="50%" cy="50%" r="55%">
							<stop offset="80%" stop-color="var(--sclera-inner-glow)" stop-opacity="0"/>
							<stop offset="100%" stop-color="var(--sclera-inner-glow)" stop-opacity="1"/>
						</radialGradient>

						<!-- ScleraOuter glow filter -->
						<filter id="scleraOuterGlow" x="-120%" y="-120%" width="340%" height="340%">
							<feGaussianBlur in="SourceGraphic" stdDeviation="15" result="blur"/>
							<feFlood flood-color="var(--sclera-outer-glow)" flood-opacity="0.4" result="col"/>
							<feComposite in="col" in2="blur" operator="in" result="glow"/>
							<feMerge>
							<feMergeNode in="glow"/>
							<feMergeNode in="SourceGraphic"/>
							</feMerge>
						</filter>
					
					<!-- IRIS -->
						<!-- Inner glow -->
						<radialGradient id="irisInnerGlow" cx="50%" cy="50%" r="50%">
							<stop offset="80%" stop-color="var(--iris-inner-glow)" stop-opacity="0"/>
							<stop offset="100%" stop-color="var(--iris-inner-glow)" stop-opacity="0.3"/>
						</radialGradient>

						<!-- Outer glow filter -->
						<filter id="irisOuterGlow" x="-120%" y="-120%" width="340%" height="340%">
							<feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur"/>
							<feFlood flood-color="var(--iris-outer-glow)" flood-opacity="0.25" result="col"/>
							<feComposite in="col" in2="blur" operator="in" result="glow"/>
							<feMerge>
							<feMergeNode in="glow"/>
							<feMergeNode in="SourceGraphic"/>
							</feMerge>
						</filter>
					
					
					<!-- Pupil -->
						<!-- Inner glow-->
						<radialGradient id="pupilInnerGlow" cx="50%" cy="50%" r="50%">
							<stop offset="80%" stop-color="var(--pupil-inner-glow)" stop-opacity="0"/>
							<stop offset="100%" stop-color="var(--pupil-inner-glow)" stop-opacity="0.5"/>
						</radialGradient>

						<!-- Outer glow filter -->
						<filter id="pupilOuterGlow" x="-120%" y="-120%" width="340%" height="340%">
							<feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur"/>
							<feFlood flood-color="var(--pupil-outer-glow)" flood-opacity="0.1" result="col"/>
							<feComposite in="col" in2="blur" operator="in" result="glow"/>
							<feMerge>
							<feMergeNode in="glow"/>
							<feMergeNode in="SourceGraphic"/>
							</feMerge>
						</filter>
				</defs>
			
				<!-- === LEFT EYE === -->
					<g id="leftEye" transform="translate(-10 0)">
					<!-- Eye Bezel -->
						<g id="eyeBezelL">
							<rect x="80" y="170" width="200" height="180" rx="80" fill="url(#bezelDark)"/>
							<rect x="85" y="170" width="200" height="180" rx="80" fill="url(#bezelMetal)"/>
							<rect x="94" y="173" width="190" height="174" rx="80" fill="#000000"/>
						</g>
					<!-- Eye Ball -->
						<g class="eyeball blink">
							<!-- Sclera (White part) -->
							<g class="sclera">
								<circle cx="200" cy="260" r="71" fill="var(--sclera-outer-glow)" filter="url(#scleraOuterGlow)"/>
								<circle cx="200" cy="260" r="70" fill="url(#scleraFill)"/>
								<circle cx="200" cy="260" r="70" fill="url(#scleraInnerGlow)"/>
							</g>
						<!-- Iris -->
							<g class="iris">
								<circle cx="200" cy="260" r="38" fill="var(--iris-outer-glow)" filter="url(#irisOuterGlow)"/>
								<circle cx="200" cy="260" r="40" fill="var(--iris-fill)"/>
								<circle cx="200" cy="260" r="40" fill="url(#irisInnerGlow)"/>
							<!-- Pupil -->
								<g class="pupil">
									<circle cx="210" cy="250" r="10" fill="var(--pupil-outer-glow)" filter="url(#pupilOuterGlow)"/>
									<circle cx="210" cy="250" r="10" fill="var(--pupil-fill)"/>
									<circle cx="210" cy="250" r="10" fill="url(#pupilInnerGlow)"/>
								</g>
							</g><!-- Iris -->
						</g><!-- Eye Ball -->
					</g><!-- === LEFT EYE === -->

				<!-- === RIGHT EYE === -->
					<g id="rightEye" transform="translate(10 0)">
					<!-- Eye Bezel -->
						<g id="eyeBezelR">
							<rect x="320" y="170" width="200" height="180" rx="80" fill="url(#bezelDark)"/>
							<rect x="315" y="170" width="200" height="180" rx="80" fill="url(#bezelMetal)"/>
							<rect x="317" y="173" width="190" height="174" rx="80" fill="#000000"/>
						</g>
					<!-- Eye Ball -->
						<g class="eyeball blink">
							<g class="sclera">
								<circle cx="400" cy="260" r="71" fill="var(--sclera-outer-glow)" filter="url(#scleraOuterGlow)"/>
								<circle cx="400" cy="260" r="70" fill="url(#scleraFill)"/>
								<circle cx="400" cy="260" r="70" fill="url(#scleraInnerGlow)"/>
							</g>
						<!-- Iris -->
							<g class="iris">
								<circle cx="400" cy="260" r="38" fill="var(--iris-outer-glow)" filter="url(#irisOuterGlow)"/>
								<circle cx="400" cy="260" r="40" fill="var(--iris-fill)"/>
								<circle cx="400" cy="260" r="40" fill="url(#irisInnerGlow)"/>
							<!-- Pupil -->
								<g class="pupil">
									<circle cx="410" cy="250" r="10" fill="var(--pupil-outer-glow)" filter="url(#pupilOuterGlow)"/>
									<circle cx="410" cy="250" r="10" fill="var(--pupil-fill)"/>
									<circle cx="410" cy="250" r="10" fill="url(#pupilInnerGlow)"/>
								</g>
							</g><!-- Iris -->
						</g><!-- Eye Ball -->
					</g><!-- === LEFT EYE === -->
				
			
				<!-- EYEBROWS -->
				 	<g id="brows">
						<path class="brow browL" d="M 100 110 Q 150 100 200 110"/>
						<path class="brow browR" d="M 400 110 Q 450 100 500 110"/>
					</g>


				<!-- Mouth -->
					<g id="mouth">
						<path class="mouth" id="mouth-bored" d="M245 370 Q300 360 355 370"/>
						<path class="mouth" id="mouth-confused" d="M240 410 Q270 395 300 410 T360 410"/>
						<path class="mouth" id="mouth-happy" d="M250 370 A70 80 0 0 0 350 370 A60 20 0 0 1 250 370 Z"/>
						<path class="mouth" id="mouth-idle" d="M240 400 Q300 410 360 400"/>
						<path class="mouth" id="mouth-listening" d="M270 400 Q280 410 330 400"/>
						<path class="mouth" id="mouth-sleeping" d="M255 350 Q300 356 345 350"/>
						<circle class="mouth" id="mouth-surprised" cx="300" cy="360" r="20"/>
						<path class="mouth" id="mouth-thinking" d="M250 402 340 408"/>
					</g>

				<!-- Cheeks / Blush -->
					<!-- 
					<ellipse cx="210" cy="340" rx="70" ry="30" fill="rgba(70,246,216,0.10)" filter="blur(8px)"/>
					<ellipse cx="390" cy="340" rx="70" ry="30" fill="rgba(70,246,216,0.10)" filter="blur(8px)"/>
					-->
			</svg><!-- Face -->



			<!-- FX layers -->
			<svg class="fx fx-rain" viewBox="0 0 1000 1000" preserveAspectRatio="none">
				<ellipse class="drop" cx="200" cy="100" rx="10" ry="24"/>
				<ellipse class="drop d2" cx="360" cy="40" rx="10" ry="24"/>
				<ellipse class="drop d3" cx="520" cy="140" rx="10" ry="24"/>
				<ellipse class="drop d2" cx="680" cy="60" rx="10" ry="24"/>
				<ellipse class="drop d3" cx="820" cy="120" rx="10" ry="24"/>
				<ellipse class="drop" cx="260" cy="220" rx="10" ry="24"/>
				<ellipse class="drop d2" cx="460" cy="260" rx="10" ry="24"/>
				<ellipse class="drop d3" cx="740" cy="240" rx="10" ry="24"/>
			</svg>

			<svg class="fx fx-wind" viewBox="0 0 1000 1000" preserveAspectRatio="none">
				<line class="streak" x1="60" y1="260" x2="260" y2="220"/>
				<line class="streak s2" x1="120" y1="420" x2="360" y2="380"/>
				<line class="streak" x1="80" y1="620" x2="340" y2="580"/>
				<line class="streak s2" x1="220" y1="760" x2="520" y2="720"/>
			</svg>

			<svg class="fx fx-hot" viewBox="0 0 1000 1000" preserveAspectRatio="none">
				<path class="shimmer" d="M180 220 C260 180 340 260 420 220 C500 180 580 260 660 220 C740 180 820 260 900 220" stroke="rgba(200,245,255,0.35)" stroke-width="10" fill="none"/>
				<ellipse class="sweat" cx="340" cy="260" rx="14" ry="22"/>
				<ellipse class="sweat" cx="660" cy="280" rx="12" ry="20" style="animation-delay:1.1s"/>
			</svg>

			<svg class="fx fx-cold" viewBox="0 0 1000 1000" preserveAspectRatio="none">
				<ellipse class="breath" cx="500" cy="620" rx="60" ry="30"/>
			</svg>

		</div> <!-- char -->
	</div> <!-- stage -->


	<div id="messages">Error - Unable to connect</div>

	<script>

		const moods = ['idle','bored','listening','thinking','surprised','confused','sleeping','happy'];
		const weathers = ['none','rain','wind','hot','cold'];




		function applyBodyClass(prefix, value, allowed, fallback){
			// remove existing prefixed classes only
			[...document.body.classList].forEach(c => { if (c.startsWith(prefix + '-')) document.body.classList.remove(c); });
			const v = (value || '').toString().trim().toLowerCase();
			document.body.classList.add(prefix + '-' + (allowed.includes(v) ? v : fallback));
		}

		function setMood(m){ 
			//document.getElementById('messages').innerText = "Setting mood to:" + m;
			applyBodyClass('mood', m, moods, 'idle'); 
		}
		function setWeather(wx){ applyBodyClass('wx', wx, weathers, 'none'); }

		function setWeatherIntensity(intensity){
			if (intensity === null || intensity === undefined) return;
			const v = Math.max(0, Math.min(1, parseFloat(intensity)));
			if (!Number.isNaN(v)) document.documentElement.style.setProperty('--weather-intensity', v.toString());
		}

		// 1) Initial state from query string
		const qs = new URLSearchParams(location.search);
		setMood(qs.get('mood') || 'idle');
		setWeather(qs.get('wx') || 'none');
		setWeatherIntensity(qs.get('int'));

		// 2) Live updates from the card (postMessage)
		window.addEventListener('message', (e) => {
			if (!e.data || e.data.type !== 'macs:mood') return;
			setMood(e.data.mood || 'idle');
		});

		// Optional: tap to navigate (works only where the scheme is supported)
		// document.addEventListener('click', () => { location.href = 'homeassistant://navigate/dashboard-home/home'; });




/* ===========================
   ASSIST PIPELINE WS – 2 TURNS (latest + previous)
   - Receives HA token + pipeline_id via postMessage from macs-card
   - Falls back to localStorage hassTokens + FALLBACK_PIPELINE_ID if needed
   =========================== */

(() => {
  "use strict";

  /* ---------- config ---------- */
  const MAX_TURNS = 2;

  // Optional fallback (kept so you can still open /local/macs/macs.html directly on the same device)
  const FALLBACK_PIPELINE_ID = "01kdke01gb6nf2apqw3nm0f6wg";

  // injected by parent (macs-card)
  let injectedToken = "";
  let injectedPipelineId = "";

  /* newest first */
  const turns = []; // [{runId, heard, reply, error, ts}]

  /* ---------- utilities ---------- */
  const esc = (s) => (s ?? "").toString().replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");

  const fmtTime = (iso) => {
    try {
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return "";
      return d.toLocaleTimeString([], { hour:"2-digit", minute:"2-digit" });
    } catch { return ""; }
  };

  const wsUrl = () => (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/api/websocket";

  const getPipelineId = () => (injectedPipelineId || FALLBACK_PIPELINE_ID || "").toString().trim();

  const getAccessToken = () => {
    if (injectedToken) return injectedToken;
    try { return JSON.parse(localStorage.getItem("hassTokens") || "null")?.access_token || ""; } catch { return ""; }
  };

  /* ---------- turn handling (KEYED BY runId) ---------- */
  const upsertTurn = (t) => {
    const idx = turns.findIndex(x => x.runId === t.runId);

    if (idx === 0) { turns[0] = { ...turns[0], ...t }; return; }

    if (idx > 0) {
      const merged = { ...turns[idx], ...t };
      turns.splice(idx, 1);
      turns.unshift(merged);
    } else {
      turns.unshift(t);
      if (turns.length > MAX_TURNS) turns.length = MAX_TURNS;
    }
  };

  /* ---------- render ---------- */
  const renderChat = () => {
    const el = document.getElementById("messages");
    if (!el) return;

    el.innerHTML = `
      <div class="assist-chat">
        ${turns.slice().reverse().map(t => {
          const userText = t.heard || "—";
          const sysText = t.error || t.reply || "—";
          const ts = t.ts ? fmtTime(t.ts) : "";

          return `
            <div class="assist-turn">
              <div class="bubble user">
                ${ts ? `<div class="bubble-meta">${esc(ts)}</div>` : ""}
                ${esc(userText)}
              </div>
              <div class="bubble system">
                ${ts ? `<div class="bubble-meta">${esc(ts)}</div>` : ""}
                ${esc(sysText)}
              </div>
            </div>
          `;
        }).join("")}
      </div>
    `;
  };

  /* ---------- parse pipeline ---------- */
  const extract = (events) => {
    let heard = "", reply = "", error = "", ts = "";
    for (const ev of (events || [])) {
      if (!ts && ev.timestamp) ts = ev.timestamp;

      if (!heard && ev.type === "intent-start") heard = ev.data?.intent_input || "";
      if (ev.type === "stt-end") heard = ev.data?.stt_output?.text || heard;

      if (ev.type === "intent-end") reply = ev.data?.intent_output?.response?.speech?.plain?.speech || reply;

      if (ev.type === "error") error = `${ev.data?.code || "error"}: ${ev.data?.message || ""}`.trim();
    }
    return { heard, reply, error, ts };
  };

  /* ---------- websocket ---------- */
  let ws = null, msgId = 1;
  let entitiesSubId = null;
  let lastSeen = { runId: null, ts: null };

  const sendWS = (payload) => {
    if (!ws || ws.readyState !== 1) return;
    ws.send(JSON.stringify({ id: msgId++, ...payload }));
  };

  const listRuns = () => {
    const pid = getPipelineId();
    if (!pid) return;
    sendWS({ type: "assist_pipeline/pipeline_debug/list", pipeline_id: pid });
  };

  const getRun = (runId) => {
    const pid = getPipelineId();
    if (!pid) return;
    sendWS({ type: "assist_pipeline/pipeline_debug/get", pipeline_id: pid, pipeline_run_id: runId });
  };

  /* ---------- debounce ---------- */
  let fetchDebounce = null;
  const triggerFetchNewest = () => {
    if (fetchDebounce) return;
    fetchDebounce = setTimeout(() => { fetchDebounce = null; listRuns(); }, 120);
  };

  /* ---------- parent handshake ---------- */
  const HA_ORIGIN = location.origin;

  const requestConfigFromParent = () => {
    try { window.parent.postMessage({ type: "macs:request_config" }, HA_ORIGIN); } catch {}
  };

  // Accept config messages from the parent card
  window.addEventListener("message", (e) => {
    if (e.origin !== HA_ORIGIN) return;         // same-origin only
    if (e.source !== window.parent) return;     // only our parent
    if (!e.data || typeof e.data !== "object") return;

    const oldToken = injectedToken;
    const oldPid = injectedPipelineId;

    if (e.data.type === "macs:config") {
      injectedToken = (e.data.token || "").toString().trim();
      injectedPipelineId = (e.data.pipeline_id || "").toString().trim();
    } else if (e.data.type === "macs:token") {
      injectedToken = (e.data.token || "").toString().trim();
    } else if (e.data.type === "macs:pipeline") {
      injectedPipelineId = (e.data.pipeline_id || "").toString().trim();
    } else {
      return;
    }

    const tokenChanged = injectedToken !== oldToken;
    const pidChanged = injectedPipelineId !== oldPid;

    // If we now have enough to run, reconnect (token/pid changes matter)
    if ((tokenChanged || pidChanged) && canConnect()) connect(true);
  });

  const canConnect = () => !!getAccessToken() && !!getPipelineId();

  /* ---------- connect ---------- */
  const connect = (reconnect = false) => {
    const token = getAccessToken();
    const pid = getPipelineId();

    if (!pid) {
      upsertTurn({
        runId: "no-pipeline",
        heard: "No pipeline id",
        reply: "",
        error: "Set pipeline_id in macs-card",
        ts: new Date().toISOString()
      });
      renderChat();
      requestConfigFromParent();
      return;
    }

    if (!token) {
      upsertTurn({
        runId: "no-token",
        heard: "Waiting for HA token…",
        reply: "",
        error: "Open this via the dashboard card (postMessage)",
        ts: new Date().toISOString()
      });
      renderChat();
      requestConfigFromParent();
      return;
    }

    // close any old socket
    try { if (ws && ws.readyState <= 1) ws.close(); } catch {}
    ws = new WebSocket(wsUrl());
    msgId = 1;
    entitiesSubId = null;

    ws.onmessage = (ev) => {
      let msg; try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "auth_required") {
        ws.send(JSON.stringify({ type: "auth", access_token: token }));
        return;
      }

      if (msg.type === "auth_ok") {
        entitiesSubId = msgId;
        sendWS({ type: "subscribe_entities" });
        listRuns();
        return;
      }

      // entity diffs: “conversation.home_assistant” ticks when Assist runs
      if (msg.type === "event" && msg.id === entitiesSubId && msg.event?.c) {
        if (msg.event.c["conversation.home_assistant"]) triggerFetchNewest();
        return;
      }

      // pipeline_debug/list
      if (msg.type === "result" && msg.success && msg.result?.pipeline_runs) {
        const newest = msg.result.pipeline_runs.at(-1);
        if (!newest) return;

        const changed = newest.pipeline_run_id !== lastSeen.runId || newest.timestamp !== lastSeen.ts;
        if (changed) {
          lastSeen = { runId: newest.pipeline_run_id, ts: newest.timestamp };
          getRun(lastSeen.runId);
          // catch intent-end / tts-end arriving slightly later
          setTimeout(() => getRun(lastSeen.runId), 250);
          setTimeout(() => getRun(lastSeen.runId), 700);
        }
        return;
      }

      // pipeline_debug/get
      if (msg.type === "result" && msg.success && msg.result?.events) {
        const parsed = { ...extract(msg.result.events), runId: lastSeen.runId || "unknown" };
        if (parsed.heard || parsed.reply || parsed.error) {
          upsertTurn(parsed);
          renderChat();
        }
        return;
      }
    };

    ws.onclose = () => setTimeout(() => connect(true), 1000);
    ws.onerror = () => { try { ws.close(); } catch {} };

    // Ask parent for config (especially important on mobile where localStorage hassTokens may be empty)
    if (!reconnect) requestConfigFromParent();
  };

  // boot
  renderChat();
  requestConfigFromParent();
  connect(false);
})();
</script>

</body>
</html>
